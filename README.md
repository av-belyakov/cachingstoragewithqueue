# Пакет cachingstoragewithqueue

Пакет cachingstoragewithqueue реализует кэширующее хранилище произвольных объектов с очередью и обработкой этих объектов в автоматическом режиме. Концептуально, хранилище состоит из двух частей. Часть, в которой организована очередь (далее - 'Очередь') из объектов подлежащих обработки и часть обеспечивающая временное хранение обрабатываемых объектов и объектов которые уже были обработаны (далее - 'Кэш').

'Очередь', хранит объекты требующие обработки. Объекты в очередь добавляются пользователем, количество добавляемых объектов для пользователя не ограничено и ограничевается только размером ОЗУ вычислительной машины.

В 'Кэш', объекты добавляются в автоматически. Есть следующие опции настройки:

- Интервал времени обработки очередей и объектов в 'Кэше' задается с помощью опциональной функции WithTimeTick(<секунды>), где допустимый интервал от 3 до 120 секунд. Если данный параметр не задан, то по умолчанию используется значение 5 секунд.
- Размер 'Кэша' устанавливается параметром WithMaxSize(<количество_объектов>). Размер 'Кэша' должен быть в диапазоне от 3 до 1000 хранимых объектов. Оснавная задача 'Кэша', хранить уже обработанные объекты, выполнять поиск в 'Кэше' только что принятых из очереди объектов, с целью обнаружения дубликатов и сравнение объектов, найденных по id. Если, в результате поиска будет найден объект с таким же id, то выполняется его полное сравнение и если объекты совпадают, объект принятый из очереди будет отброшен. Если, объект не совпадает, то объект из 'Кэша' будет заменён новым объектом.
- Допустимое время хранение объектов в 'Кэше' устанавливается параметром WithMaxTtl(<секунды>). Диапазон данного параметра от 300 до 86400 секунд. Значение по умолчанию составляет 3600 секунд.

Обработка объектов может выполнятся как в синхронном так и в асинхронном режиме. В синхронном режиме объекты обрабатываются по очереди, от самого старого объекта, время жизни 'timeExpiry' которого наименьшее к самому новому. При асинхронном режиме объекты запускаются на выполнение группами в количестве задаваемом параметром WithEnableAsyncProcessing(<количество_объектов>) и при наличии объектов ожидающих в очереди. Асинхронный режив включается только если значение заданное WithEnableAsyncProcessing составляет 2 и более.

Объекты удаляются из 'Кэша' только в двух случаях:

1. По истечении времени жизни объекта.
2. При совпадении следующих условий:

- количество объектов в 'Кэше' превышает значение установленое параметром WithMaxSize;
- исполняемая функция объекта была успешно выполнена или количество попыток выполнения исполняемой функции превышает 3;
- объект олжен иметь минимальное время жизни из всех объектов находящихся в 'Кэше'

Для использования пакета необходимо создать любой вспомогательный пользовательский тип который реализует интерфейс CacheStorageHandler. Пакет может хранить и работать с любыми пользовательскими типами.

#### Подробно об использовании в примере ниже:

1. Инициализируем новое хранилище где 'any' любой тип данных который будет добавлятся в очередь и хранится в кэше как исходный объект. В тестах используется специально созданный интерфейс SpecialObjectComparator обладающий определённым набором методов:

```
	cache, err = cachingstoragewithq//кладем в очередь объекты которые необходимо обработать
		addObjectToQueue(listId)ueue.NewCacheStorage[<тип_объекта>](
		context.Background(),
		cachingstoragewithqueue.WithMaxTtl[<тип_объекта>](int),
		cachingstoragewithqueue.WithTimeTick[<тип_объекта>](int),
		cachingstoragewithqueue.WithMaxSize[<тип_объекта>](int))
```

При инициализации хранилища запускается модуль CacheStorageWithQueue.automaticExecution обеспечивающий автоматическую обработку объектов добавленных в очередь. Этот модуль выполняет обработку объектов, хранение заданного максимального количества объектов, сравнение объектов на наличие дубликатов, удаление старых объектов. То есть объектов, срок жизни которых истёк или объектов, которые были успешно выполнены, если максимальное количество которых превышает допустимое значение выставляе мое методом cachingstoragewithqueue.WithMaxSize.

2.  Добавление нового объекта в очередь:
    Для добавления объекта в очередь нужно использовать любой вспомогательный объект который реализует интерфейс CacheStorageFuncHandler[T any].
    Например, используем пользовательский тип SpecialObjectForCache со вспомогательным интерфейсом SpecialObjectComparator,
    который, в том числе реализует методы сравнения схожих объектов для каждого из свойств объекта

```
type SpecialObjectForCache[T SpecialObjectComparator] struct {
	object      T
	handlerFunc func(int) bool
	id          string
}

func NewSpecialObjectForCache[T SpecialObjectComparator]() *SpecialObjectForCache[T] {
	return &SpecialObjectForCache[T]{}
}
```

Реализуем необходимые методы

```
func (o *SpecialObjectForCache[T]) SetID(v string) {
	o.id = v
}

func (o *SpecialObjectForCache[T]) GetID() string {
	return o.id
}

func (o *SpecialObjectForCache[T]) SetObject(v T) {
	o.object = v
}

func (o *SpecialObjectForCache[T]) GetObject() T {
	return o.object
}

func (o *SpecialObjectForCache[T]) SetFunc(f func(int) bool) {
	o.handlerFunc = f
}

func (o *SpecialObjectForCache[T]) GetFunc() func(int) bool {
	return o.handlerFunc
}

func (o *SpecialObjectForCache[T]) Comparison(objFromCache T) bool {
    //некие сравнения...

    return true
}
```

Добавляем вспомогательный объект в очередь хранилища

```
cache.PushObjectToQueue(CacheStorageFuncHandler[T any])
```

После добавления вспомогательного объекта в очередь основная работа выполняется автоматически внутри хранилища.

ЗДЕСЬ ПОЗЖЕ НЕОБХОДИМО ОПИСАТЬ ПОДРОБНЫЙ ХОД ВЫПОЛНЕНИЯ ЗАДАЧИ

Подробный пример использования пакета, можно посмотреть в файле package_test.go где для тестирования используются наборы типов и методов из пакета github.com/av-belyakov/objectsmispformat применяемых для упрощения взаимодействия с API MISP.
